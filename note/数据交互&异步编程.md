[toc]

# 1 服务器的基本概念

## 1.1 客户端与服务器

- 负责存放和对外提供资源的电脑，叫做服务器

- 负责获取和消费资源的电脑，叫做客户端

## 1.2 URL地址

- URL（全称是UniformResourceLocator）中文叫统一资源定位符，用于标识互联网上每个资源的唯一存放位置。浏览器只有通过URL地址，才能正确定位资源的存放位置，从而成功访问到对应的资源。

- URL地址一般由三部组成：

  ① 客户端与服务器之间的通信协议

  ② 存有该资源的服务器名称

  ③ 资源在服务器上具体的存放位置

## 1.3 网页的打开过程

①客户端与服务器之间的通信过程，分为 请求 – 处理 – 响应 三个步骤。

②网页中的每一个资源，都是通过 请求 – 处理 – 响应 的方式从服务器获取回来的。

## 1.4 服务器对外提供了哪些资源

### 1.4.1 数据请求

- 如果要在网页中请求服务器上的数据资源，则需要用到 XMLHttpRequest 对象。

XMLHttpRequest（简称 xhr）是浏览器提供的 js 成员，通过它，可以请求服务器上的数据资源。

- 最简单的用法 var xhrObj = new XMLHttpRequest()

### 1.4.2 请求方式

客户端请求服务器时，请求的方式有很多种，最常见的两种请求方式分别为 get 和 post 请求。

- get 请求通常用于获取服务端资源（向服务器要资源）

   例如：根据 URL 地址，从服务器获取 HTML 文件、css 文件、js文件、图片文件、数据资源等



- post 请求通常用于向服务器提交数据（往服务器发送资源）

   例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作

## 1.5 Ajax

- Ajax 的全称是 Asynchronous Javascript And XML（异步 JavaScript 和 XML）。

- 通俗的理解：在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。

- Ajax能让我们轻松实现网页与服务器之间的数据交互。

### 1.5.1 jQuery中的Ajax

#### $.get() 

$.get() 函数的功能单一，专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。

```jQuery
$.**get**(**url**, [data], [callback])
```

| **参数名** | **参数类型** | **是否必选** | **说明**                 |
| ---------- | ------------ | ------------ | ------------------------ |
| url        | string       | 是           | 要请求的资源地址         |
| data       | object       | 否           | 请求资源期间要携带的参数 |
| callback   | function     | 否           | 请求成功时的回调函数     |

- $.get()发起不带参数的请求

```html
  <script src="./lib/jquery.js"></script>

  <button id="btnGET">发起不带参数的GET请求</button>
  <script>
    $(function () {
      $('#btnGET').on('click', function () {
        $.get('http://www.liulongbin.top:3006/api/getbooks', function (res) {
          console.log(res)
        })
      })
    })
  </script>
```

- $.get()发起带参数的请求

```html
  <button id="btnGETINFO">发起单参数的GET请求</button>
  <script>
    $(function () {
      $('#btnGETINFO').on('click', function () {
        $.get('http://www.liulongbin.top:3006/api/getbooks', { id: 1 }, function (res) {
          console.log(res)
        })
      })
    })
  </script>
```

#### $.post()

jQuery 中 $.post() 函数的功能单一，专门用来发起 post 请求，从而向服务器提交数据。

```
$.post(url, [data], [callback])
```

| **参数名** | **参数类型** | **是否必选** | **说明**                 |
| ---------- | ------------ | ------------ | ------------------------ |
| url        | string       | 是           | 提交数据的地址           |
| data       | object       | 否           | 要提交的数据             |
| callback   | function     | 否           | 数据提交成功时的回调函数 |

- $.post()向服务器提交数据

```html
  <button id="btnPOST">发起POST请求</button>

  <script>
    $(function () {
      $('#btnPOST').on('click', function () {
        $.post('http://www.liulongbin.top:3006/api/addbook', { bookname: '水浒传', author: '施耐庵', publisher: '天津图书出版社' }, function (res) {
          console.log(res)
        })
      })
    })
  </script>
```

#### $.ajax()

```
$.ajax({
   type: '', // 请求的方式，例如 GET 或 POST
   url: '',  // 请求的 URL 地址
   data: { },// 这次请求要携带的数据
   success: function(res) { } // 请求成功之后的回调函数
})
```

```html
 //使用$.ajax()发起GET请求
  <button id="btnGET">发起GET请求</button>
  <script>
    $(function () {
      $('#btnGET').on('click', function () {
        $.ajax({
          type: 'GET',
          url: 'http://www.liulongbin.top:3006/api/getbooks',
          data: {
            id: 1
          },
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
  </script>
```

```html
  //使用$.ajax()发起POST请求
  <button id="btnPOST">发起POST请求</button>
  <script>
    $(function () {
      $('#btnPOST').on('click', function () {
        $.ajax({
          type: 'POST',
          url: 'http://www.liulongbin.top:3006/api/addbook',
          data: {
            bookname: '史记',
            author: '司马迁',
            publisher: '上海图书出版社'
          },
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
  </script>
```

## 1.6 接口

- 使用 Ajax 请求数据时，被请求的 URL 地址，就叫做数据接口（简称接口。每个接口必须有请求方式

### 1.6.1 接口测试工具

- 接口测试工具能让我们在不写任何代码的情况下，对接口进行调用和测试。

- https://www.getpostman.com/downloads/

### 1.6.2 接口文档

**接口的说明文档，它是我们调用接口的依据**。好的接口文档包含了对接口URL，参数以及输出内容的说明，我们参照接口文档就能方便的知道接口的作用，以及接口如何进行调用。

1. **接口名称**：用来标识各个接口的简单说明，如登录接口，获取图书列表接口等。

2. **接口****URL**：接口的调用地址。

3. **调用方式**：接口的调用方式，如 GET 或 POST。

4. **参数格式**：接口需要传递的参数，每个参数必须包含参数名称、参数类型、是否必选、参数说明这4项内容。

5. **响应格式**：接口的返回值的详细描述，一般包含数据名称、数据类型、说明3项内容。

6. 返回示例（可选）：通过对象的形式，例举服务器返回数据的结构。

### 1.6.3 案例一

- 代理的方式为动态添加的元素绑定点击事件

https://blog.csdn.net/xiaozhi_2016/article/details/52184328

```html
 <link rel="stylesheet" href="./lib/bootstrap.css" />
 <script src="./lib/jquery.js"></script> 
 
 <body style="padding: 15px;">
  <!-- 添加图书的Panel面板 -->
  <div class="panel panel-primary">
    <div class="panel-heading">
      <h3 class="panel-title">添加新图书</h3>
    </div>
    <div class="panel-body form-inline">

      <div class="input-group">
        <div class="input-group-addon">书名</div>
        <input type="text" class="form-control" id="iptBookname" placeholder="请输入书名">
      </div>

      <div class="input-group">
        <div class="input-group-addon">作者</div>
        <input type="text" class="form-control" id="iptAuthor" placeholder="请输入作者">
      </div>

      <div class="input-group">
        <div class="input-group-addon">出版社</div>
        <input type="text" class="form-control" id="iptPublisher" placeholder="请输入出版社">
      </div>

      <button id="btnAdd" class="btn btn-primary">添加</button>

    </div>
  </div>
  
<!-- 图书的表格 -->
  <table class="table table-bordered table-hover">
    <thead>
      <tr>
        <th>Id</th>
        <th>书名</th>
        <th>作者</th>
        <th>出版社</th>
        <th>操作</th>
      </tr>
    </thead>
    <tbody id="tb"></tbody>
  </table>

  <script>
    $(function () {
      // 获取图书列表数据
      function getBookList() {
        $.get('http://www.liulongbin.top:3006/api/getbooks', function (res) {
          if (res.status !== 200) return alert('获取数据失败！')

          var rows = []
          $.each(res.data, function (i, item) {
            rows.push('<tr><td>' + item.id + '</td><td>' + item.bookname + '</td><td>' + item.author + '</td><td>' + item.publisher + '</td><td><a href="javascript:;" class="del" data-id="' + item.id + '">删除</a></td></tr>')
          })
          $('#tb').empty().append(rows.join(''))
        })
      }

      getBookList()

      /* $('.del').on('click', function () {
        console.log('ok')
      }) */

      // 通过代理的方式为动态添加的元素绑定点击事件
      $('tbody').on('click', '.del', function () {
        var id = $(this).attr('data-id')
        $.get('http://www.liulongbin.top:3006/api/delbook', { id: id }, function (res) {
          if (res.status !== 200) return alert('删除图书失败！')
          getBookList()
        })
      })

      $('#btnAdd').on('click', function () {
          //.trim 去除字符串两端空格
        var bookname = $('#iptBookname').val().trim()
        var author = $('#iptAuthor').val().trim()
        var publisher = $('#iptPublisher').val().trim()
        if (bookname.length <= 0 || author.length <= 0 || publisher.length <= 0) {
          return alert('请填写完整的图书信息！')
        }

        $.post('http://www.liulongbin.top:3006/api/addbook', { bookname: bookname, author: author, publisher: publisher }, function (res) {
          if (res.status !== 201) return alert('添加图书失败！')
          getBookList()
          $('#iptBookname').val('')
          $('#iptAuthor').val('')
          $('#iptPublisher').val('')
        })
      })
    })
  </script>
```



### 1.6.4 案例二

```html
  <!-- 注意：只要为 audio 指定了新的 src 属性，而且指定了 autoplay，那么，语音就会自动播放 -->
  <audio src="" id="voice" autoplay style="display: none;"></audio>
```



```javascript
$(function () {
  // 初始化右侧滚动条
  // 这个方法定义在scroll.js中
  resetui()

  // 为发送按钮绑定鼠标点击事件
  $('#btnSend').on('click', function () {
    var text = $('#ipt').val().trim()
    if (text.length <= 0) {
      return $('#ipt').val('')
    }
    // 如果用户输入了聊天内容，则将聊天内容追加到页面上显示
    $('#talk_list').append('<li class="right_word"><img src="img/person02.png" /> <span>' + text + '</span></li>')
    $('#ipt').val('')
    // 重置滚动条的位置
    resetui()
    // 发起请求，获取聊天内容
    getMsg(text)
  })

  // 获取聊天机器人发送回来的消息
  function getMsg(text) {
    $.ajax({
      method: 'GET',
      url: 'http://ajax.frontend.itheima.net:3006/api/robot',
      data: {
        spoken: text
      },
      success: function (res) {
        // console.log(res)
        if (res.message === 'success') {
          // 接收聊天消息
          var msg = res.data.info.text
          $('#talk_list').append('<li class="left_word"><img src="img/person01.png" /> <span>' + msg + '</span></li>')
          // 重置滚动条的位置
          resetui()
          // 调用 getVoice 函数，把文本转化为语音
          getVoice(msg)
        }
      }
    })
  }

  // 把文字转化为语音进行播放
  function getVoice(text) {
    $.ajax({
      method: 'GET',
      url: 'http://ajax.frontend.itheima.net:3006/api/synthesize',
      data: {
        text: text
      },
      success: function (res) {
        // console.log(res)
        if (res.status === 200) {
          // 播放语音
          $('#voice').attr('src', res.voiceUrl)
        }
      }
    })
  }

  // 为文本框绑定 keyup 事件
  $('#ipt').on('keyup', function (e) {
    // console.log(e.keyCode)
    if (e.keyCode === 13) {
      // console.log('用户弹起了回车键')
      $('#btnSend').click()
    }
  })
})
```



# 2 form表单与模板引擎

## 2.1 form表单的使用

### 2.1.1 表单定义

- 表单在网页中主要负责**数据采集功能**。HTML中的<form>标签，就是用于采集用户输入的信息，并通过<form>标签的提交操作，把采集到的信息提交到服务器端进行处理。

### 2.1.2 表单组成部分

表单由三个基本部分组成：

- 表单标签

- 表单域

- 表单按钮

```html
<form>
    <input type="text" name="email_or_mobile" />
    <input type="password" name="password" />
    <input type="checkbox" name="remember_me" checked />
    <button type="submit">提交</button>
</form>
```

- 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。

### 2.1.3 form标签属性

| **属性** | **值**                                                       | **描述**                                   |
| -------- | ------------------------------------------------------------ | ------------------------------------------ |
| action   | URL地址                                                      | 规定当提交表单时，向何处发送表单数据       |
| method   | get或post                                                    | 规定以何种方式把表单数据提交到 action  URL |
| enctype  | application/x-www-form-urlencoded  multipart/form-data  text/plain | 规定在发送表单数据之前如何对其进行编码     |
| target   | _blank  _self  _parent  _top  *framename*                    | 规定在何处打开 action  URL                 |

#### action

- action 属性用来规定当提交表单时，**向何处发送表单数据**。

- action 属性的值应该是后端提供的一个 URL 地址，这个 URL 地址专门负责接收表单提交过来的数据。

- 当 <form> 表单在未指定 action 属性值的情况下，action 的默认值为当前页面的 URL 地址。
- 当提交表单后，页面会立即跳转到 action 属性指定的 URL 地址

#### target

- target 属性用来规定**在何处打开** **action URL**。
- 它的可选值有5个，**默认情况下，target 的值是 _self**，表示在相同的框架中打开 action URL。

| **值**      | **描述**                       |
| ----------- | ------------------------------ |
| **_blank**  | **在新窗口中打开。**           |
| **_self**   | **默认。在相同的框架中打开。** |
| _parent     | 在父框架集中打开。（很少用）   |
| _top        | 在整个窗口中打开。（很少用）   |
| *framename* | 在指定的框架中打开。（很少用） |

#### method

- method 属性用来规定**以何种方式**把表单数据提交到 action URL。

- 它的可选值有两个，分别是 get 和 post。

- 默认情况下，method 的值为 get，表示通过URL地址的形式，把表单数据提交到 action URL。



- get 方式适合用来提交少量的、简单的数据。
- post 方式适合用来提交大量的、复杂的、或包含文件上传的数据。
- 在实际开发中，<form> 表单的 post 提交方式用的最多，很少用 get。例如登录、注册、添加数据等表单操作，都需要使用 post 方式来提交表单。

#### enctype

- enctype 属性用来规定在**发送表单数据之前如何对数据进行编码**。

- 它的可选值有三个，默认情况下，enctype 的值为 application/x-www-form-urlencoded，表示在发送前编码所有的字符。

| **值**                            | **描述**                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| application/x-www-form-urlencoded | 在发送前编码所有字符（默认）                                 |
| multipart/form-data               | 不对字符编码。  在使用包含文件上传控件的表单时，必须使用该值。 |
| text/plain                        | 空格转换为 “+”  加号，但不对特殊字符编码。（很少用）         |

- 在涉及到**文件上传**的操作时，**必须**将 enctype 的值设置为 multipart/form-data

- 如果表单的提交不涉及到文件上传操作，则直接将 enctype 的值设置为 application/x-www-form-urlencoded 即可！

### 2.1.3 表单的同步提交及缺点

- 通过点击 submit 按钮, 触发表单提交的操作, 从而使页面跳转到 action URL 的行为, 叫做表单的同步提交。

  ①<form>表单同步提交后，整个页面会发生跳转，**跳转到** **action URL** **所指向的地址**，用户体验很差。

  ②<form>表单同步提交后，**页面之前的状态和数据会丢失**。

- 解决方案：**表单只负责采集数据**，**Ajax** **负责将数据提交到服务器**。

## 2.2 通过Ajax提交表单数据

### 2.2.1 监听表单提交事件

```javascript
<form action="/login" id="form1">
    <input type="text" name="user_name" />
    <input type="password" name="password" />
    <button type="submit">提交</button>\
</form>

$('#form1').submit(function(e) {
   alert('监听到了表单的提交事件')
})

$('#form1').on('submit', function(e) {
   alert('监听到了表单的提交事件')
})
```

### 2.2.2 阻止表单默认提交行为

```javascript
$('#form1').submit(function(e) {
   // 阻止表单的提交和页面的跳转
   e.preventDefault()
})

$('#form1').on('submit', function(e) {
   // 阻止表单的提交和页面的跳转
   e.preventDefault()
})
```

### 2.2.3 快速获取表单中的数据

- serialize()函数,可以一次性获取到表单中的所有的数据。

```javascript
$(selector).serialize()
```

```html
<form id="form1">
    <input type="text" name="username" />
    <input type="password" name="password" />
    <button type="submit">提交</button>
</form>
```

```javascript
$('#form1').on('submit', function(e) {
   // 阻止表单的提交和页面的跳转
   e.preventDefault()
   $('#form1').serialize()
})
// 调用的结果：
// username=用户名的值&password=密码的值
```

- 注意：在使用 serialize() 函数快速获取表单数据时，**必须为每个表单元素添加** **name** **属性**！

## 2.3 案例评论列表

```html
<body style="padding: 15px;">

  <!-- 评论面板 -->
  <div class="panel panel-primary">
    <div class="panel-heading">
      <h3 class="panel-title">发表评论</h3>
    </div>
    <form class="panel-body" id="formAddCmt">
      <div>评论人：</div>
      <input type="text" class="form-control" name="username" autocomplete="off" />
      <div>评论内容：</div>
      <textarea class="form-control" name="content"></textarea>

      <button type="submit" class="btn btn-primary">发表评论</button>
    </form>
  </div>


  <!-- 评论列表 -->
  <ul class="list-group" id="cmt-list">
    <li class="list-group-item">
      <span class="badge" style="background-color: #F0AD4E;">评论时间：</span>
      <span class="badge" style="background-color: #5BC0DE;">评论人：</span>
      Item 1
    </li>
  </ul>

</body>
```

```JavaScript
// 获取评论列表
function getCommentList() {
  $.ajax({
    method: 'GET',
    url: 'http://www.liulongbin.top:3006/api/cmtlist',
    success: function (res) {
      if (res.status !== 200) return alert('获取评论列表失败！')
      var rows = []
      $.each(res.data, function (i, item) {
        var str = '<li class="list-group-item"><span class="badge" style="background-color: #F0AD4E;">评论时间：' + item.time + '</span><span class="badge" style="background-color: #5BC0DE;">评论人：' + item.username + '</span>' + item.content + '</li>'
        rows.push(str)
      })
      $('#cmt-list').empty().append(rows.join(''))
    }
  })
}

getCommentList()
// 发表评论
$(function () {
  $('#formAddCmt').submit(function (e) {
    e.preventDefault()
    var data = $(this).serialize()
    $.post('http://www.liulongbin.top:3006/api/addcmt', data, function (res) {
      if (res.status !== 201) {
        return alert('发表评论失败！')
      }
      getCommentList()
      $('#formAddCmt')[0].reset() // 将jQuery转换成原生DOM对象
    })
  })
})

```

## 2.4 模板引擎的基本概念

### 2.4.1 渲染UI结构时遇到的问题

```javascript
var rows = []
$.each(res.data, function (i, item) { // 循环拼接字符串
    rows.push('<li class="list-group-item">'+ item.content +'<span class="badge cmt-date">评论时间：'+ item.time +'</span><span class="badge cmt-person">评论人：'+ item.username +'</span></li>')
})
$('#cmt-list').empty().append(rows.join('')) // 渲染列表的UI结构

```

- 上述代码是通过**字符串拼接**的形式，来渲染UI结构。

- 如果UI结构比较复杂，则拼接字符串的时候需要格外注意**引号之前的嵌套**。且一旦需求发生变化，**修改起来也非常麻烦**。

### 2.4.2 模板引擎定义

它可以根据程序员指定的模板结构和数据，自动生成一个完整的HTML页面。

优势：

①减少了字符串的拼接操作

②使代码结构更清晰

③使代码更易于阅读与维护

## 2.5 art-template模板引擎

http://aui.github.io/art-template/zh-cn/index.html

### 2.5.1 基本使用

#### 1 使用传统方式渲染UI结构

```JavaScript
<body>
  <div id="title"></div>
  <div>姓名：<span id="name"></span></div>
  <div>年龄：<span id="age"></span></div>
  <div>会员：<span id="isVIP"></span></div>
  <div>注册时间：<span id="regTime"></span></div>
  <div>爱好：
    <ul id="hobby">
      <li>爱好1</li>
      <li>爱好2</li>
    </ul>
  </div>

  <script>
    var data = {
      title: '<h3>用户信息</h3>',
      name: 'zs',
      age: 20,
      isVIP: true,
      regTime: new Date(),
      hobby: ['吃饭', '睡觉', '打豆豆']
    }


    $(function () {
      $('#name').html(data.name)
      $('#title').html(data.title)
      $('#age').html(data.age)
      $('#isVIP').html(data.isVIP)
      $('#regTime').html(data.regTime)

      var rows = []
      $.each(data.hobby, function (i, item) {
        rows.push('<li>' + item + '</li>')
      })
      $('#hobby').html(rows.join(''))
    })
  </script>
</body>
```

#### 2 使用步骤

①导入 art-template

②定义数据

③定义模板

④调用 template 函数

⑤渲染HTML结构

```html
<body>
  <div id="container"></div>

  <!-- 3. 定义模板 -->
  <!-- 3.1 模板的 HTML 结构，必须定义到 script 中 -->
  <script type="text/html" id="tpl-user">
    <h1>{{name}}</h1>
  </script>

  <script>
    // 2. 定义需要渲染的数据
    var data = { name: 'zs'}

    // 4. 调用 template 函数
    var htmlStr = template('tpl-user', data)
    console.log(htmlStr)
    // 5. 渲染HTML结构
    $('#container').html(htmlStr)
  </script>
</body>
```



### 2.5.2 标准语法

art-template 提供了 **{{ }}** 这种语法格式，在 {{ }} 内可以进行**变量输出**，或**循环数组**等操作，这种 {{ }} 语法在 art-template 中被称为标准语法。

#### 1 输出

在 {{ }} 语法中，可以进行变量的输出、对象属性的输出、三元表达式输出、逻辑或输出、加减乘除等表达式输出。

```javascript
{{value}}
{{obj.key}}
{{obj['key']}}
{{a ? b : c}}
{{a || b}}
{{a + b}}
```

#### 2 原文输出

如果要输出的 value 值中, 包含了 HTML 标签结构, 则需要使用原文输出语法, 才能保证 HTML 标签被正常渲染。

```javascript
{{@ value }}
```

#### 3 条件输出

如果要实现条件输出，则可以在 {{ }} 中使用 **if** … **else if** … **/if** 的方式，进行按需输出。

```javascript
{{if value}} 按需输出的内容 {{/if}}

{{if v1}} 按需输出的内容 {{else if v2}} 按需输出的内容 {{/if}}

```

#### 4 循环输出

如果要实现循环输出，则可以在 {{ }} 内，通过 each 语法循环数组，当前循环的索引使用 **$index** 进行访问，当前的循环项使用 **$value** 进行访问。

```javascript
{{each arr}}
    {{$index}} {{$value}}
{{/each}}
```

#### 5 过滤器

过滤器语法类似**管道操作符**，它的上一个输出作为下一个输入。

定义过滤器的基本语法如下：

```javascript
template.defaults.imports.filterName = function(value){/*return处理的结果*/}
```

```javascript
{{value | filterName}}
```

```javascript
<div>注册时间：{{regTime | dateFormat}}</div>
// 定义一个格式化时间的过滤器 dateFormat 如下：
 template.defaults.imports.dateFormat = function(date) {
    var y = date.getFullYear()
    var m = date.getMonth() + 1
    var d = date.getDate()

    return y + '-' + m + '-' + d // 注意，过滤器最后一定要 return 一个值
 }
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <!-- 1. 导入模板引擎 -->
  <!-- 在 window 全局，多一个函数，叫做 template('模板的Id', 需要渲染的数据对象) -->
  <script src="./lib/template-web.js"></script>
  <script src="./lib/jquery.js"></script>
</head>

<body>

  <div id="container"></div>

  <!-- 3. 定义模板 -->
  <!-- 3.1 模板的 HTML 结构，必须定义到 script 中 -->
  <script type="text/html" id="tpl-user">
    <h1>{{name}}    ------    {{age}}</h1>
    {{@ test}}

    <div>
      {{if flag === 0}}
      flag的值是0
      {{else if flag === 1}}
      flag的值是1
      {{/if}}
    </div>

    <ul>
      {{each hobby}}
      <li>索引是:{{$index}}，循环项是:{{$value}}</li>
      {{/each}}
    </ul>

    <h3>{{regTime | dateFormat}}</h3>
  </script>

  <script>
    // 定义处理时间的过滤器
    template.defaults.imports.dateFormat = function (date) {
      var y = date.getFullYear()
      var m = date.getMonth() + 1
      var d = date.getDate()

      return y + '-' + m + '-' + d
    }


    // 2. 定义需要渲染的数据
    var data = { name: 'zs', age: 20, test: '<h3>测试原文输出</h3>', flag: 1, hobby: ['吃饭', '睡觉', '写代码'], regTime: new Date() }

    // 4. 调用 template 函数
    var htmlStr = template('tpl-user', data)
    console.log(htmlStr)
    // 5. 渲染HTML结构
    $('#container').html(htmlStr)
  </script>
</body>

</html>
```

### 2.5.4 案例 – 新闻列表

```javascript
$(function () {
  // 给时间补零的函数
  function padZero(n) {
    if (n < 10) {
      return '0' + n
    } else {
      return n
    }
  }

  // 定义格式化时间的过滤器
  template.defaults.imports.dateFormat = function (dtStr) {
    var dt = new Date(dtStr)

    var y = dt.getFullYear()
    var m = padZero(dt.getMonth() + 1)
    var d = padZero(dt.getDate())

    var hh = padZero(dt.getHours())
    var mm = padZero(dt.getMinutes())
    var ss = padZero(dt.getSeconds())

    return y + '-' + m + '-' + d + ' ' + hh + ':' + mm + ':' + ss
  }

  // 获取新闻列表的函数
  function getNewsList() {
    $.get('http://www.liulongbin.top:3006/api/news', function (res) {
      if (res.status !== 200) {
        return alert('获取新闻列表数据失败！')
      }
      for (var i = 0; i < res.data.length; i++) {
        // 把每一项的 tags 属性，从字符串改造成字符串的数组
        res.data[i].tags = res.data[i].tags.split(',')
      }
      console.log(res)
      var htmlStr = template('tpl-news', res)
      $('#news-list').html(htmlStr)
    })
  }

  getNewsList()

})

```

```html
 <!-- 定义模板 -->
  <script type="text/html" id="tpl-news">
      {{each data}}
      <div class="news-item">
        <img class="thumb" src="{{'http://www.liulongbin.top:3006' + $value.img}}" alt="" />
        <div class="right-box">
          <h1 class="title">{{$value.title}}</h1>
          <div class="tags">
            {{each $value.tags}}
            <span>{{$value}}</span>
            {{/each}}
          </div>
          <div class="footer">
            <div>
              <span>{{$value.source}}</span>&nbsp;&nbsp;
              <span>{{$value.time | dateFormat}}</span>
            </div>
            <span>评论数：{{$value.cmtcount}}</span>
          </div>
        </div>
      </div>
      {{/each}}
    </script>
```

## 2.6 模板引擎的实现原理

### 2.6.1 正则与字符串操作

#### 1 基本语法

exec() 函数用于检索字符串中的正则表达式的匹配。

如果字符串中有匹配的值，则返回该匹配值，否则返回 null。

```javascript
RegExpObject.exec(string)
var str = 'hello'
var pattern = /o/
// 输出的结果["o", index: 4, input: "hello", groups: undefined]
console.log(pattern.exec(str)) 

```

#### 2 分组

正则表达式中 ( ) 包起来的内容表示一个分组，可以通过分组来**提取自己想要的内容**，示例代码如下：

```javascript
 var str = '<div>我是{{name}}</div>'
 var pattern = /{{([a-zA-Z]+)}}/

 var patternResult = pattern.exec(str)
 console.log(patternResult)
 // 得到 name 相关的分组信息
 // ["{{name}}", "name", index: 7, input: "<div>我是{{name}}</div>", groups: undefined]
```

#### 3 字符串的replace函数

replace() 函数用于在字符串中用一些字符**替换**另一些字符，语法格式如下：

```javascript
var result = '123456'.replace('123', 'abc') // 得到的 result 的值为字符串 'abc456'

var str = '<div>我是{{name}}</div>'
var pattern = /{{([a-zA-Z]+)}}/

var patternResult = pattern.exec(str)
str = str.replace(patternResult[0], patternResult[1]) // replace 函数返回值为替换后的新字符串
// 输出的内容是：<div>我是name</div>
console.log(str)
```

#### 4 多次replace

```javascript
var str = '<div>{{name}}今年{{ age }}岁了</div>'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = pattern.exec(str)
str = str.replace(patternResult[0], patternResult[1])
console.log(str) // 输出 <div>name今年{{ age }}岁了</div>

patternResult = pattern.exec(str)
str = str.replace(patternResult[0], patternResult[1])
console.log(str) // 输出 <div>name今年age岁了</div>

patternResult = pattern.exec(str)
console.log(patternResult) // 输出 null

```

#### 5 使用while循环replace

```javascript
var str = '<div>{{name}}今年{{ age }}岁了</div>'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = null
while(patternResult = pattern.exec(str)) {
   str = str.replace(patternResult[0], patternResult[1])
}
console.log(str) // 输出 <div>name今年age岁了</div>
```

#### 6 replace替代为真值

```javascript
var data = { name: '张三', age: 20 }
var str = '<div>{{name}}今年{{ age }}岁了</div>'
var pattern = /{{\s*([a-zA-Z]+)\s*}}/

var patternResult = null
while ((patternResult = pattern.exec(str))) {
   str = str.replace(patternResult[0], data[patternResult[1]])
}
console.log(str)
```

### 2.6.2 实现简易的模板引擎

#### 1 实现步骤

①定义模板结构

②预调用模板引擎

③封装 template 函数

④导入并使用自定义的模板引擎

#### 2 定义模板结构

```javascript
<!-- 定义模板结构 -->
<script type="text/html" id="tpl-user">
   <div>姓名：{{name}}</div>
   <div>年龄：{{ age }}</div>
   <div>性别：{{  gender}}</div>
   <div>住址：{{address  }}</div>
</script>
```

#### 3 预调用模板引擎

```javascript
<script>
   // 定义数据
   var data = { name: 'zs', age: 28, gender: '男', address: '北京顺义马坡' }
   // 调用模板函数
   var htmlStr = template('tpl-user', data)
   // 渲染HTML结构
   document.getElementById('user-box').innerHTML = htmlStr
</script>

```

#### 4 封装template函数

```javascript
function template(id, data) {
  var str = document.getElementById(id).innerHTML
  var pattern = /{{\s*([a-zA-Z]+)\s*}}/
  var pattResult = null
  while ((pattResult = pattern.exec(str))) {
    str = str.replace(pattResult[0], data[pattResult[1]])
  }
  return str
}
```

#### 5 导入并使用自定义的模板引擎

```html
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>自定义模板引擎</title>
    <!-- 导入自定义的模板引擎 -->
    <script src="./js/template.js"></script>
</head>

```

# 3 Ajax 加强

## 3.1 XMLHttpRequest的基本使用

XMLHttpRequest（简称 xhr）是浏览器提供的 Javascript 对象，通过它，可以**请求服务器上的数据资源**。之前所学的 jQuery 中的 Ajax 函数，就是基于 xhr 对象封装出来的。

xml对象的属性：https://www.cnblogs.com/shilingjing/p/15377832.html

### 3.1.1 使用xhr发起GET请求

①创建 xhr 对象

②调用 xhr.open() 函数

③调用 xhr.send() 函数

④监听 xhr.onreadystatechange 事件

```javascript
// 1. 创建 XHR 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open 函数，指定 请求方式 与 URL地址
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
// 3. 调用 send 函数，发起 Ajax 请求
xhr.send()
// 4. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    // 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 4.2 打印服务器响应回来的数据
        console.log(xhr.responseText)
    }
}
```

### 3.1.2 readyState属性

XMLHttpRequest 对象的 readyState 属性，用来表示**当前** **Ajax** **请求所处的状态**。每个 Ajax 请求必然处于以下状态中的一个：

| **值** | **状态**         | **描述**                                             |
| ------ | ---------------- | ---------------------------------------------------- |
| 0      | UNSENT           | XMLHttpRequest  对象已被创建，但尚未调用  open方法。 |
| 1      | OPENED           | open() 方法已经被调用。                              |
| 2      | HEADERS_RECEIVED | send() 方法已经被调用，响应头也已经被接收。          |
| 3      | LOADING          | 数据接收中，此时  response  属性中已经包含部分数据。 |
| 4      | DONE             | Ajax  请求完成，这意味着数据传输已经彻底完成或失败。 |

### 3.1.3 使用xhr发起带参数的GET请求

使用 xhr 对象发起带参数的 GET 请求时，只需在调用 xhr.open 期间，为 URL 地址指定参数即可：

```javascript
// 1. 创建 XHR 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open 函数，指定 请求方式 与 URL地址
xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks?id=1')
// 3. 调用 send 函数，发起 Ajax 请求
xhr.send()
// 4. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    // 4.1 监听 xhr 对象的请求状态 readyState ；与服务器响应的状态 status
    if (xhr.readyState === 4 && xhr.status === 200) {
        // 4.2 打印服务器响应回来的数据
        console.log(xhr.responseText)
    }
}
```

这种在 URL 地址后面拼接的参数，叫做**查询字符串**

### 3.1.4 查询字符串

定义：查询字符串（URL 参数）是指在 URL 的末尾加上用于向服务器发送信息的字符串（变量）。

格式：将英文的 **?** 放在URL 的末尾，然后再加上 **参数＝值** ，想加上多个参数的话，使用 **&** 符号进行分隔。以这个形式，可以将想要发送给服务器的数据添加到 URL 中。

```markdown
// 不带参数的 URL 地址
http://www.liulongbin.top:3006/api/getbooks
// 带一个参数的 URL 地址
http://www.liulongbin.top:3006/api/getbooks?id=1
// 带两个参数的 URL 地址
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
```

### 3.1.5 GET请求携带参数的本质

$.ajax()或者直接使用 xhr 对象发起 GET 请求，当需要携带参数的时候，本质上，都是直接将参数以查询字符串的形式，追加到 URL 地址的后面，发送到服务器的。

```JavaScript
$.get('url', {name: 'zs', age: 20}, function() {})
// 等价于
$.get('url?name=zs&age=20', function() {})

$.ajax({ method: 'GET', url: 'url', data: {name: 'zs', age: 20}, success: function() {} })
// 等价于
$.ajax({ method: 'GET', url: 'url?name=zs&age=20', success: function() {} })
```

### 3.1.6 URL解码和编码

URL 地址中，只允许出现英文相关的字母、标点符号、数字，因此，在 URL 地址中不允许出现中文字符。

如果 URL 中需要包含中文这样的字符，则必须对中文字符进行**编码**（转义）。

**URL编码的原则**：使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。

URL编码原则的通俗理解：使用英文字符去表示非英文字符。

```markdown
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=西游记
// 经过 URL 编码之后，URL地址变成了如下格式：
http://www.liulongbin.top:3006/api/getbooks?id=1&bookname=%E8%A5%BF%E6%B8%B8%E8%AE%B0
```

#### 1 对URL进行编码与解码

- encodeURI() 编码的函数

- decodeURI() 解码的函数

```markdown
encodeURI('黑马程序员')
// 输出字符串  %E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98
decodeURI('%E9%BB%91%E9%A9%AC')
// 输出字符串  黑马
```

#### 2 注意事项

由于浏览器会自动对 URL 地址进行编码操作，因此，大多数情况下，程序员不需要关心 URL 地址的编码与解码操作。



更多关于 URL 编码的知识，请参考如下博客：

https://blog.csdn.net/Lxd_0111/article/details/78028889

### 3.1.7 使用xhr发起POST请求

①创建 xhr 对象

②调用 xhr.open() 函数

③**设置** **Content-Type** **属性**（固定写法）

④调用 xhr.send() 函数，**同时指定要发送的数据**

⑤监听 xhr.onreadystatechange 事件

```JavaScript
// 1. 创建 xhr 对象
var xhr = new XMLHttpRequest()
// 2. 调用 open()
xhr.open('POST', 'http://www.liulongbin.top:3006/api/addbook')
// 3. 设置 Content-Type 属性（固定写法）
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
// 4. 调用 send()，同时将数据以查询字符串的形式，提交给服务器
xhr.send('bookname=水浒传&author=施耐庵&publisher=天津图书出版社')
// 5. 监听 onreadystatechange 事件
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText)
    }
}
```

## 3.2 数据交换格式

- 数据交换格式，就是服务器端与客户端之间进行数据传输与交换的格式。

- 前端领域，经常提及的两种数据交换格式分别是 XML 和 JSON。其中 XML 用的非常少，所以，我们重点要学习的数据交换格式就是 JSON。

### 3.2.1 XML

- XML 的英文全称是 E**X**tensible **M**arkup **L**anguage，即**可扩展标记语言**。因此，XML 和 HTML 类似，也是一种标记语言。

- XML 和 HTML 虽然都是标记语言，但是，它们两者之间没有任何的关系。

  - HTML 被设计用来描述网页上的**内容**，是网页内容的载体

  - XML 被设计用来**传输和存储数据**，是数据的载体

- 缺点：
  - XML 格式臃肿，和数据无关的代码多，体积大，传输效率低
  - 在 Javascript 中解析 XML 比较麻烦

### 3.2.2 JSON

- 概念：JSON 的英文全称是 JavaScript Object Notation，即“JavaScript 对象表示法”。简单来讲，JSON 就是 Javascript 对象和数组的字符串表示法，它使用文本表示一个 JS 对象或数组的信息，因此，**JSON** **的本质是字符串**。
- 作用：JSON 是一种轻量级的文本数据交换格式，在作用上类似于 XML，专门用于存储和传输数据，但是 JSON 比 XML 更小、更快、更易解析。
- 现状：JSON 是在 2001 年开始被推广和使用的数据格式，到现今为止，JSON 已经成为了主流的数据交换格式。
- JSON 就是用字符串来表示 Javascript 的对象和数组。所以，JSON 中包含**对象**和**数组**两种结构，通过这两种结构的相互嵌套，可以表示各种复杂的数据结构。
- - **对象结构**：对象结构在 JSON 中表示为 { } 括起来的内容。数据结构为 { key: value, key: value, … } 的键值对结构。其中，key 必须是使用英文的双引号包裹的字符串，value 的数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型。

```
{
   "name": "zs",
    "age": 20,
    "gender": "男",
    "address": null,
    "hobby": ["吃饭", "睡觉", "打豆豆"]
}
```

  - - **数组结构**：数组结构在 JSON 中表示为 [ ] 括起来的内容。数据结构为 [ "java", "javascript", 30, true … ] 。数组中数据的类型可以是数字、字符串、布尔值、null、数组、对象6种类型。。

```
[ "java", "python", "php" ]
[ 100, 200, 300.5 ]
[ true, false, null ]
[ { "name": "zs", "age": 20}, { "name": "ls", "age": 30} ]
[ [ "苹果", "榴莲", "椰子" ], [ 4, 50, 5 ] ]
```

### 3.2.3 JSON使用注意事项

- ①属性名必须使用双引号包裹

- ②字符串类型的值必须使用双引号包裹

- ③JSON 中不允许使用单引号表示字符串

- ④JSON 中不能写注释

- ⑤JSON 的最外层必须是对象或数组格式

- ⑥不能使用 undefined 或函数作为 JSON 的值

- JSON 的作用：在计算机与网络之间存储和传输数据。

- JSON 的本质：用字符串来表示 Javascript 对象数据或数组数据

### 3.2.4 JSON和JS对象的关系

```javascript
//这是一个对象
var obj = {a: 'Hello', b: 'World'}

//这是一个 JSON 字符串，本质是一个字符串
var json = '{"a": "Hello", "b": "World"}' 

```

- 要实现从 JSON 字符串转换为 JS 对象，使用 JSON.parse() 方法：

```javascript
var obj = JSON.parse('{"a": "Hello", "b": "World"}')
//结果是 {a: 'Hello', b: 'World'}
```

- 要实现从 JS 对象转换为 JSON 字符串，使用 JSON.stringify() 方法：

```javascript
var json = JSON.stringify({a: 'Hello', b: 'World'})
//结果是 '{"a": "Hello", "b": "World"}'
```

- 把数据对象转换为字符串的过程，叫做**序列化**，调用 JSON.stringify() 函数的操作，叫做 JSON 序列化。
- 把字符串转换为数据对象的过程，叫做**反序列化**，调用 JSON.parse() 函数的操作，叫做 JSON 反序列化。

## 3.3 封装自己的Ajax函数

```javascript
<!-- 1. 导入自定义的ajax函数库 -->
<script src="./itheima.js"></script>

<script>
    // 2. 调用自定义的 itheima 函数，发起 Ajax 数据请求
    itheima({
        method: '请求类型',
        url: '请求地址',
        data: { /* 请求参数对象 */ },
        success: function(res) { // 成功的回调函数
            console.log(res)     // 打印数据
        }
    })
</script>
```

### 3.3.1 定义options参数选项

itheima() 函数是我们自定义的 Ajax 函数，它接收一个配置对象作为参数，配置对象中可以配置如下属性：

- method  请求的类型

- url      请求的 URL 地址

- data    请求携带的数据

- success  请求成功之后的回调函数

### 3.3.2 处理data参数

需要把 data 对象，转化成查询字符串的格式，从而提交给服务器，因此提前定义 resolveData 函数如下：

```javascript
/**
 * 处理 data 参数
 * @param {data} 需要发送到服务器的数据
 * @returns {string} 返回拼接好的查询字符串 name=zs&age=10
 */
function resolveData(data) {
  var arr = []
  for (var k in data) {
    arr.push(k + '=' + data[k])
  }
  return arr.join('&')
}
```

### 3.3.3 定义itheima函数

在 itheima() 函数中，需要创建 xhr 对象，并监听 onreadystatechange 事件：

```javascript
function itheima(options) {
  var xhr = new XMLHttpRequest()
  // 拼接查询字符串
  var qs = resolveData(options.data)

  // 监听请求状态改变的事件
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
      var result = JSON.parse(xhr.responseText)
      options.success(result)
    }
  }
}
```

### 3.3.4 判断请求的类型

不同的请求类型，对应 xhr 对象的不同操作，因此需要对请求类型进行 if … else … 的判断：

```javascript
  if (options.method.toUpperCase() === 'GET') {
    // 发起 GET 请求
    xhr.open(options.method, options.url + '?' + qs)
    xhr.send()
  } else if (options.method.toUpperCase() === 'POST') {
    // 发起 POST 请求
    xhr.open(options.method, options.url)
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
    xhr.send(qs)
  }
```

## 3.4 XMLHttpRequest Level2的新特性

### 3.4.1 旧版XMLHttpRequest的缺点

①只支持文本数据的传输，无法用来读取和上传文件

②传送和接收数据时，没有进度信息，只能提示有没有完成

### 3.4.2 XMLHttpRequest Level2的新功能

#### ①可以设置 HTTP 请求的时限

- 有时，Ajax 操作很耗时，而且无法预知要花多少时间。如果网速很慢，用户可能要等很久。新版本的 XMLHttpRequest 对象，增加了 timeout 属性，可以设置 HTTP 请求的时限：

```javascript
xhr.timeout = 3000
```

- 上面的语句，将最长等待时间设为 3000 毫秒。过了这个时限，就自动停止HTTP请求。与之配套的还有一个 timeout 事件，用来指定回调函数：

```javascript
 xhr.ontimeout = function(event){
     alert('请求超时！')
 }
```

```javascript
  <script>
    var xhr = new XMLHttpRequest()

    // 设置 超时时间
    xhr.timeout = 30
    // 设置超时以后的处理函数
    xhr.ontimeout = function () {
      console.log('请求超时了！')
    }

    xhr.open('GET', 'http://www.liulongbin.top:3006/api/getbooks')
    xhr.send()

    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText)
      }
    }
  </script>
```

#### ②可以使用 FormData 对象管理表单数据

- Ajax 操作往往用来提交表单数据。为了方便表单处理，HTML5 新增了一个 FormData 对象，可以模拟表单操作：

```javascript
      // 1. 新建 FormData 对象
      var fd = new FormData()
      // 2. 为 FormData 添加表单项
      fd.append('uname', 'zs')
      fd.append('upwd', '123456')
      // 3. 创建 XHR 对象
      var xhr = new XMLHttpRequest()
      // 4. 指定请求类型与URL地址
      xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
      // 5. 直接提交 FormData 对象，这与提交网页表单的效果，完全一样
      xhr.send(fd)
```

- FormData对象也可以用来获取网页表单的值，示例代码如下：

```javascript
 // 获取表单元素
 var form = document.querySelector('#form1')
 // 监听表单元素的 submit 事件
 form.addEventListener('submit', function(e) {
    e.preventDefault()
     // 根据 form 表单创建 FormData 对象，会自动将表单数据填充到 FormData 对象中
     var fd = new FormData(form)
     var xhr = new XMLHttpRequest()
     xhr.open('POST', 'http://www.liulongbin.top:3006/api/formdata')
     xhr.send(fd)
     xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
          console.log(JSON.parse(xhr.responseText))
        }
     }
})

```

#### ③可以上传文件

新版 XMLHttpRequest 对象，不仅可以发送文本信息，还可以上传文件。

- 实现步骤：

1. 定义 UI 结构
2. 验证是否选择了文件
3. 向 FormData 中追加文件
4. 使用 xhr 发起上传文件的请求
5. 监听 onreadystatechange 事件
6. 可以获得数据传输的进度信息

```javascript
// 1.定义UI结构
  <!-- 1. 文件选择框 -->
  <input type="file" id="file1" />
  <!-- 2. 上传文件的按钮 -->
  <button id="btnUpload">上传文件</button>
  <br />
  <!-- 3. img 标签，来显示上传成功以后的图片 -->
  <img src="" alt="" id="img" width="800" />
// 2.验证是否选择了文件
  <script>
    // 1. 获取到文件上传按钮
    var btnUpload = document.querySelector('#btnUpload')
    // 2. 为按钮绑定单击事件处理函数
    btnUpload.addEventListener('click', function () {
      // 3. 获取到用户选择的文件列表
      var files = document.querySelector('#file1').files
      if (files.length <= 0) {
        return alert('请选择要上传的文件！')
      }
// 3.向FormData中追加文件
      var fd = new FormData()
      // 将用户选择的文件，添加到 FormData 中
      fd.append('avatar', files[0])
// 4.使用 xhr 发起上传文件的请求
      var xhr = new XMLHttpRequest()
      xhr.open('POST', 'http://www.liulongbin.top:3006/api/upload/avatar')
      xhr.send(fd)
// 5.监听onreadystatechange事件
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          var data = JSON.parse(xhr.responseText)
          if (data.status === 200) {
            // 上传成功
            document.querySelector('#img').src = 'http://www.liulongbin.top:3006' + data.url
          } else {
            // 上传失败
            console.log('图片上传失败！' + data.message)
          }
        }
      }
    })
  </script>
```

#### ④显示文件上传进度

新版本的 XMLHttpRequest 对象中，可以通过监听 xhr.upload.onprogress 事件，来获取到文件的上传进度。语法格式如下：

```javascript
 // 创建 XHR 对象
 var xhr = new XMLHttpRequest()
 // 监听 xhr.upload 的 onprogress 事件
 xhr.upload.onprogress = function(e) {
    // e.lengthComputable 是一个布尔值，表示当前上传的资源是否具有可计算的长度
    if (e.lengthComputable) {
        // e.loaded 已传输的字节
        // e.total  需传输的总字节
        var percentComplete = Math.ceil((e.loaded / e.total) * 100)
    }
 }
```

1. 导入需要的库

```html
    <link rel="stylesheet" href="./lib/bootstrap.css" />
    <script src="./lib/jquery.js"></script>
```

2. 基于Bootstrap渲染进度条

```html
    <!-- 进度条 -->
    <div class="progress" style="width: 500px; margin: 10px 0;">
      <div class="progress-bar progress-bar-info progress-bar-striped active" id="percent" style="width: 0%">
        0%
      </div>
    </div>
```

3. 监听上传进度的事件

```javascript
xhr.upload.onprogress = function(e) {
    if (e.lengthComputable) {
    // 1. 计算出当前上传进度的百分比
    var percentComplete = Math.ceil((e.loaded / e.total) * 100)
    $('#percent')
        // 2. 设置进度条的宽度
        .attr('style', 'width:' + percentComplete + '%')
        // 3. 显示当前的上传进度百分比
        .html(percentComplete + '%')
    }
 }
```

4. 监听上传完成的事件

```javascript
 xhr.upload.onload = function() {
     $('#percent')
         // 移除上传中的类样式
         .removeClass()
         // 添加上传完成的类样式
         .addClass('progress-bar progress-bar-success')
 }
```

## 3.5 jQuery高级用法

### 3.5.1 jQuery实现文件上传

```html
<body>
// 1. 定义UI结构
  <input type="file" id="file1" />
  <button id="btnUpload">上传文件</button>

  <br />
  <img src="./images/loading.gif" alt="" style="display: none;" id="loading" />

  <script>
    $(function () {
      // 监听到Ajax请求被发起了
      $(document).ajaxStart(function () {
        $('#loading').show()
      })

      // 监听到 Ajax 完成的事件
      $(document).ajaxStop(function () {
        $('#loading').hide()
      })
// 2. 验证是否选择了文件
      $('#btnUpload').on('click', function () {
        var files = $('#file1')[0].files
        if (files.length <= 0) {
          return alert('请选择文件后再上传！')
        }
// 3. 向FormData中追加文件

        var fd = new FormData()
        fd.append('avatar', files[0])
          
// 4. 使用jQuery发起上传文件的请求
        $.ajax({
          method: 'POST',
          url: 'http://www.liulongbin.top:3006/api/upload/avatar',
          data: fd,
          processData: false,
          contentType: false,
          success: function (res) {
            console.log(res)
          }
        })
      })
    })
  </script>

</body>
```

### 3.5.2 jQuery实现loading效果

1. ajaxStart(callback)

Ajax 请求**开始**时，执行 ajaxStart 函数。可以在 ajaxStart 的 callback 中显示 loading 效果，示例代码如下：

```javascript
 // 自 jQuery 版本 1.8 起，该方法只能被附加到文档
 $(document).ajaxStart(function() {
     $('#loading').show()
 })
```

注意： $(document).ajaxStart() 函数**会监听当前文档内所有的** **Ajax** **请求**。

2. ajaxStop(callback)

Ajax 请求**结束**时，执行 ajaxStop 函数。可以在 ajaxStop 的 callback 中隐藏 loading 效果，示例代码如下：

```javascript
 // 自 jQuery 版本 1.8 起，该方法只能被附加到文档
 $(document).ajaxStop(function() {
     $('#loading').hide()
 })
```

## 3.6 axios

- Axios 是专注于**网络数据请求**的库。

- 相比于原生的 XMLHttpRequest 对象，axios **简单易用**。

- 相比于 jQuery，axios 更加**轻量化**，只专注于网络数据请求。

### 3.6.1 axios发起GET请求

```javascript
 axios.get('**url**', { **params**: **{** /*参数*/ **}** }).then(callback)
```

```javascript
 // 请求的 URL 地址
 var url = 'http://www.liulongbin.top:3006/api/get'
 // 请求的参数对象
 var paramsObj = { name: 'zs', age: 20 }
 // 调用 axios.get() 发起 GET 请求
 axios.get(url, { params: paramsObj }).then(function(res) {
     // res.data 是服务器返回的数据
     var result = res.data
     console.log(res)
 })
```

### 3.6.2 axios发起POST请求

```javascript
 axios.post('url', { /*参数*/ }).then(callback)
```

```javascript
 // 请求的 URL 地址
 var url = 'http://www.liulongbin.top:3006/api/post'
 // 要提交到服务器的数据
 var dataObj = { location: '北京', address: '顺义' }
 // 调用 axios.post() 发起 POST 请求
 axios.post(url, dataObj).then(function(res) {
     // res.data 是服务器返回的数据
     var result = res.data
     console.log(result)
 })
```

### 3.6.3 直接使用axios发起请求

```javascript
 axios({
     method: '请求类型',
     url: '请求的URL地址',
     data: { /* POST数据 */ },
     params: { /* GET参数 */ }
 }) .then(callback)
```

#### 1 直接使用axios发起GET请求

```java
 axios({
     method: 'GET',
     url: 'http://www.liulongbin.top:3006/api/get',
     params: { // GET 参数要通过 params 属性提供
         name: 'zs',
         age: 20
     }
 }).then(function(res) {
     console.log(res.data)
 })
```

#### 2 直接使用axios发起POST请求

```javascript
 axios({
     method: 'POST',
     url: 'http://www.liulongbin.top:3006/api/post',
     data: { // POST 数据要通过 data 属性提供
         bookname: '程序员的自我修养',
         price: 666
     }
 }).then(function(res) {
     console.log(res.data)
 })
```

#### 3 async 修饰

这个 axios 返回值是Promise实例，如果返回值是Promise实例，就可以在前面添加 await

await 只能用在被 async 修饰的方法中

```javascript
document.querySelector('#btnPost').addEventListener('click', async function () {
  // 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！
  // await 只能用在被 async “修饰”的方法中
  const { data } = await axios({
    method: 'POST',
    url: 'http://www.liulongbin.top:3006/api/post',
    data: {
      name: 'zs',
      age: 20
    }
  })
  console.log(data)
})
```

#### 4 解构赋值

```JavaScript
document.querySelector('#btnGet').addEventListener('click', async function () {
  // 解构赋值的时候，使用 : 进行重命名
  // 1. 调用 axios 之后，使用 async/await 进行简化
  // 2. 使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来
  // 3. 把解构出来的 data 属性，使用 冒号 进行重命名，一般都重命名为 { data: res }
  const { data: res } = await axios({
    method: 'GET',
    url: 'http://www.liulongbin.top:3006/api/getbooks'
  })
  console.log(res.data)
})
```

### 3.6.4 axios直接发起 GET 和 POST 请求

```javascript
document.querySelector('#btnGET').addEventListener('click', async function () {
  /* axios.get('url地址', {
    // GET 参数
    params: {}
  }) */

  const { data: res } = await axios.get('http://www.liulongbin.top:3006/api/getbooks', {
    params: { id: 1 }
  })
  console.log(res)
})

document.querySelector('#btnPOST').addEventListener('click', async function () {
  // axios.post('url', { /* POST 请求体数据 */ })
  const { data: res } = await axios.post('http://www.liulongbin.top:3006/api/post', { name: 'zs', gender: '女' })
  console.log(res)
})
```

# 4 跨域与JSONP

## 4.1 了解同源策略和跨域

- 同源: 如果两个页面的协议，域名和端口都相同，则两个页面具有**相同的源**。

例如，下表给出了相对于 http://www.test.com/index.html 页面的同源检测：

| **URL**                            | **是否同源** | **原因**                                  |
| ---------------------------------- | ------------ | ----------------------------------------- |
| http://www.test.com/other.html     | 是           | 同源（协议、域名、端口相同）              |
| https://www.test.com/about.html    | 否           | 协议不同（http  与  https）               |
| http://blog.test.com/movie.html    | 否           | 域名不同（www.test.com 与 blog.test.com） |
| http://www.test.com:7001/home.html | 否           | 端口不同（默认的  80 端口与  7001 端口）  |
| http://www.test.com:80/main.html   | 是           | 同源（协议、域名、端口相同）              |

- **同源策略**（英文全称 Same origin policy）是浏览器提供的一个安全功能。

MDN 官方给定的概念：同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。

通俗的理解：浏览器规定，A 网站的 JavaScript，不允许和非同源的网站 C 之间，进行资源的交互，例如：

①无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB

②无法接触非同源网页的 DOM

③无法向非同源地址发送 Ajax 请求

- 跨域：**同源**指的是两个 URL 的协议、域名、端口一致，反之，则是**跨域**。

​       出现跨域的根本原因：**浏览器的同源策略**不允许非同源的 URL 之间进行资源的交互。

​       网页：http://www.test.com/index.html

​       接口：http://www.api.com/userlist

![搜狗截图20220823153245](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020105999.bmp)

- **如何实现跨域数据请求**：

现如今，实现跨域数据请求，最主要的两种解决方案，分别是 JSONP 和 CORS。

JSONP：出现的早，兼容性好（兼容低版本IE）。是前端程序员为了解决跨域问题，被迫想出来的一种临时解决方案。缺点是只支持 GET 请求，不支持 POST 请求。

CORS：出现的较晚，它是 W3C 标准，属于跨域 Ajax 请求的根本解决方案。支持 GET 和 POST 请求。缺点是不兼容某些低版本的浏览器。

## 4.2 JSONP

JSONP (JSON with Padding) 是 JSON 的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。

### 4.2.1 JSONP实现原理

由于浏览器同源策略的限制，网页中无法通过 Ajax 请求非同源的接口数据。但是 <script> 标签不受浏览器同源策略的影响，可以通过 src 属性，请求非同源的 js 脚本。

因此，JSONP 的实现原理，就是通过 <script> 标签的 src 属性，请求跨域的数据接口，并通过**函数调用**的形式，接收跨域接口响应回来的数据。

### 4.2.2 简单的JSONP文件

定义一个success回调函数：

```html
 <script>
   function success(data) {
     console.log('获取到了data数据：')
     console.log(data)
   }
 </script>
```

通过 <script> 标签，请求接口数据：

```html
<script src="http://ajax.frontend.itheima.net:3006/api/jsonp?callback=success&name=zs&age=20"></script>
```

### 4.2.3 缺点

由于 JSONP 是通过 <script> 标签的 src 属性，来实现跨域数据获取的，所以，JSONP 只支持 GET 数据请求，不支持 POST 请求。



注意：**JSONP** **和** **Ajax** **之间没有任何关系**，不能把 JSONP 请求数据的方式叫做 Ajax，因为 JSONP 没有用到 XMLHttpRequest 这个对象。

## 4.3 jQuery中的JSONP

jQuery 提供的 $.ajax() 函数，除了可以发起真正的 Ajax 数据请求之外，还能够发起 JSONP 数据请求，例如：

```JavaScript
 $.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    // 如果要使用 $.ajax() 发起 JSONP 请求，必须指定 datatype 为 jsonp
    dataType: 'jsonp',
    success: function(res) {
       console.log(res)
    }
 })
```

默认情况下，使用 jQuery 发起 JSONP 请求，会自动携带一个 callback=jQueryxxx 的参数，jQueryxxx 是随机生成的一个回调函数名称。

## 4.4 自定义参数及回调函数名称

在使用 jQuery 发起 JSONP 请求时，如果想要自定义 JSONP 的**参数**以及**回调函数名称**，可以通过如下两个参数来指定：

```JavaScript
 $.ajax({
    url: 'http://ajax.frontend.itheima.net:3006/api/jsonp?name=zs&age=20',
    dataType: 'jsonp',
    // 发送到服务端的参数名称，默认值为 callback
    jsonp: 'callback',
    // 自定义的回调函数名称，默认值为 jQueryxxx 格式
    jsonpCallback: 'abc',
    success: function(res) {
       console.log(res)
    }
 })
```

## 4.5 jQuery中JSONP的实现过程

jQuery 中的 JSONP，也是通过 <script> 标签的 src 属性实现跨域数据访问的，只不过，jQuery 采用的是**动态创建和移除** **<script>** **标签**的方式，来发起 JSONP 数据请求。

- 在发起 JSONP 请求的时候，动态向 <header> 中 append 一个 <script> 标签；

- 在 JSONP 请求成功以后，动态从 <header> 中移除刚才 append 进去的 <script> 标签；

## 4.3 案例-淘宝搜索

### 4.3.1 获取用户输入的搜索关键词

为了获取到用户每次按下键盘输入的内容，需要监听输入框的 keyup 事件，示例代码如下：

```javascript
 // 监听文本框的 keyup 事件
 $('#ipt').on('keyup', function() {
   // 获取用户输入的内容
   var keywords = $(this).val().trim()
   // 判断用户输入的内容是否为空
   if (keywords.length <= 0) {
     return
   }
   // TODO：获取搜索建议列表
 })
```

### 4.3.2 封装getSuggestList函数

将获取搜索建议列表的代码，封装到 getSuggestList 函数中，示例代码如下：

```javascript
 function getSuggestList(kw) {
   $.ajax({
      // 指定请求的 URL 地址，其中，q 是用户输入的关键字
      url: 'https://suggest.taobao.com/sug?q=' + kw,
      // 指定要发起的是 JSONP 请求
      dataType: 'jsonp',
      // 成功的回调函数
      success: function(res) { console.log(res) }
   })
 }
```

### 4.3.3 渲染建议列表的UI结构

#### 1 **定义搜索建议列表**

```html
 <div class="box">
    <!-- tab 栏区域 -->
    <div class="tabs"></div>
    <!-- 搜索区域 -->
    <div class="search-box"></div>
    <!-- 搜索建议列表 -->
    <div id="suggest-list"></div>
 </div>
```

#### 2  定义模板结构

```html
 <!-- 模板结构 -->
 <script type="text/html" id="tpl-suggestList">
    {{each result}}
       <div class="suggest-item">{{$value[0]}}</div>
    {{/each}}
 </script>
```

#### 3 定义渲染模板结构的函数

```javascript
 // 渲染建议列表
 function renderSuggestList(res) {
    // 如果没有需要渲染的数据，则直接 return
    if (res.result.length <= 0) {
       return $('#suggest-list').empty().hide()
    }
    // 渲染模板结构
    var htmlStr = template('tpl-suggestList', res)
    $('#suggest-list').html(htmlStr).show()
 }
```

#### 4 搜索关键词为空时隐藏搜索建议列表

```javascript
 $('#ipt').on('keyup', function() {
    // 获取用户输入的内容
    var keywords = $(this).val().trim()
    // 判断用户输入的内容是否为空
    if (keywords.length <= 0) {
       // 如果关键词为空，则清空后隐藏搜索建议列表
       return $('#suggest-list').empty().hide()
    }
    getSuggestList(keywords)
 })
```

#### 5 输入框的防抖

- **防抖策略**（debounce）是当事件被触发后，延迟 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。

- 防抖应用场景：用户在输入框中连续输入一串字符时，可以通过防抖策略，只在输入完后，才执行查询的请求，这样可以有效减少请求次数，节约请求资源；

```javascript
 var timer = null                    // 1. 防抖动的 timer

 function debounceSearch(keywords) { // 2. 定义防抖的函数
    timer = setTimeout(function() {
    // 发起 JSONP 请求
    getSuggestList(keywords)
    }, 500)
 }

 $('#ipt').on('keyup', function() {  // 3. 在触发 keyup 事件时，立即清空 timer
    clearTimeout(timer)
    // ...省略其他代码
    debounceSearch(keywords)
 })
```

#### 6 缓存搜索的建议列表

```javascript
// 1. 定义全局缓存对象
  // 缓存对象
  var cacheObj = {}
  
// 2. 将搜索结果保存到缓存对象中
 // 渲染建议列表
 function renderSuggestList(res) {
    // ...省略其他代码
    // 将搜索的结果，添加到缓存对象中
    var k = $('#ipt').val().trim()
    cacheObj[k] = res
 }
 
// 3. 优先从缓存中获取搜索建议
 // 监听文本框的 keyup 事件
 $('#ipt').on('keyup', function() {
    // ...省略其他代码

    // 优先从缓存中获取搜索建议
    if (cacheObj[keywords]) {
       return renderSuggestList(cacheObj[keywords])
    }
    // 获取搜索建议列表
    debounceSearch(keywords)
  })
```



## 4.4 防抖和节流

**节流策略**（throttle），顾名思义，可以减少一段时间内事件的触发频率。

**节流的应用场景**:

①鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次；

②懒加载时要监听计算滚动条的位置，但不必每次滑动都触发，可以降低计算的频率，而不必去浪费 CPU 资源；

### 4.4.1 鼠标跟随效果

#### 1 渲染UI结构并美化样式

```javascript
<!-- UI 结构 -->
<img src="./assets/angel.gif" alt="" id="angel" />

/* CSS 样式 */
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
} 
#angel {
  position: absolute;
}

```

#### 2 不使用节流实现鼠标跟随效果

```javascript
$(function() {
   // 获取图片元素
   var angel = $('#angel')
   // 监听文档的 mousemove 事件
   $(document).on('mousemove', function(e) {      // 设置图片的位置
      $(angel).css('left', e.pageX + 'px').css('top', e.pageY + 'px')
   })
})
```

#### 3 使用节流实现鼠标跟随效果

```javascript
$(function() {
  var angel = $('#angel')
  var timer = null // 1.预定义一个 timer 节流阀
  $(document).on('mousemove', function(e) {
    if (timer) { return } // 3.判断节流阀是否为空，如果不为空，则证明距离上次执行间隔不足16毫秒
    timer = setTimeout(function() {
      $(angel).css('left', e.pageX + 'px').css('top', e.pageY + 'px')
      timer = null // 2.当设置了鼠标跟随效果后，清空 timer 节流阀，方便下次开启延时器
    }, 16)
  })
})
```

- 防抖：如果事件被频繁触发，防抖能保证只有最有一次触发生效！前面 N 多次的触发都会被忽略！

- 节流：如果事件被频繁触发，节流能够减少事件触发的频率，因此，节流是有选择性地执行一部分事件！



# 5 HTTP协议加强

## 5.1 HTTP协议简介

通信，就是**信息的传递和交换**。



通信三要素：

- 通信的主体，是服务器和客户端浏览器；
- 通信的内容，是传智专修学院的简介；
- 通信的方式，是响应；



**通信协议**（Communication Protocol）是指通信的双方完成通信所必须遵守的规则和约定。

- 通俗的理解：通信双方采用约定好的格式来发送和接收消息，这种事先约定好的通信格式，就叫做通信协议。

- 客户端与服务器之间要实现网页内容的传输，则通信的双方必须遵守网页内容的传输协议。

- 网页内容又叫做**超文本**，因此网页内容的传输协议又叫做**超文本传输协议**（HyperText Transfer Protocol） ，简称 **HTTP** **协议**。



**HTTP** **协议**即超文本传送协议 (HyperText Transfer Protocol) ，它规定了客户端与服务器之间进行网页内容传输时，所必须遵守的传输格式。

例如：

- 客户端要以HTTP协议要求的格式把数据提交到服务器

- 服务器要以HTTP协议要求的格式把内容响应给客户端

  ![搜狗截图20220823165127](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020105829.bmp)

## 5.2 HTTP请求

由于 HTTP 协议属于客户端浏览器和服务器之间的通信协议。因此，客户端发起的请求叫做 **HTTP** **请求**，客户端发送到服务器的消息，叫做 **HTTP** **请求消息**。



注意：HTTP 请求消息又叫做 HTTP 请求报文。

### 5.2.1 http请求消息的组成部分

HTTP 请求消息由请求行（request line）、请求头部（ header ） 、空行 和 请求体 4 个部分组成。

![图片1](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020105495.jpg)

#### 1 请求行

**请求行**由请求方式、URL 和 HTTP 协议版本 3 个部分组成，他们之间使用空格隔开。

![图片2](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020105222.png)

#### 2 请求头部

**请求头部**用来描述客户端的基本信息，从而把客户端相关的信息告知服务器。比如：User-Agent 用来说明当前是什么类型的浏览器；Content-Type 用来描述发送到服务器的数据格式；Accept 用来描述客户端能够接收什么类型的返回内容；Accept-Language 用来描述客户端期望接收哪种人类语言的文本内容。

请求头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。

![图片3](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020105920.png)

| **头部字段**    | **说明**                                       |
| --------------- | ---------------------------------------------- |
| Host            | 要请求的服务器域名                             |
| Connection      | 客户端与服务器的连接方式(close  或  keepalive) |
| Content-Length  | 用来描述请求体的大小                           |
| Accept          | 客户端可识别的响应内容类型列表                 |
| User-Agent      | 产生请求的浏览器类型                           |
| Content-Type    | 客户端告诉服务器实际发送的数据类型             |
| Accept-Encoding | 客户端可接收的内容压缩编码形式                 |
| Accept-Language | 用户期望获得的自然语言的优先顺序               |

[ https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)

#### 3 空行

最后一个请求头字段的后面是一个**空行**，通知服务器请求头部至此结束。

请求消息中的空行，用来分隔请求头部与请求体。

![图片4](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106960.png)

#### 4 请求体

请求体中存放的，是要通过 POST 方式提交到服务器的数据。

**注意**：只有 POST 请求才有请求体，GET 请求没有请求体！

## 5.3 HTTP响应

- 响应消息就是服务器响应给客户端的消息内容，也叫作响应报文。

- HTTP响应消息由状态行、响应头部、空行 和 响应体 4 个部分组成。

![图片6](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106536.png)

#### 1 状态行

**状态行**由 HTTP 协议版本、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;

![图片7](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106456.png)

#### 2 响应头部

**响应头部**用来描述服务器的基本信息。响应头部由多行 键/值对 组成，每行的键和值之间用英文的冒号分隔。

![图片3](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106255.png)

常见响应头部字段：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers

#### 3 空行

在最后一个响应头部字段结束之后，会紧跟一个**空行**，用来通知客户端响应头部至此结束。

响应消息中的空行，用来分隔响应头部与响应体。

![图片4](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106872.png)

#### 4 响应体

响应体中存放的，是服务器响应给客户端的资源内容。

## 5.4 HTTP请求方法

HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是 GET 和 POST。

| 序号 | 方法    | **描述**                                                     |
| ---- | ------- | ------------------------------------------------------------ |
| 1    | GET     | (查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。 |
| 2    | POST    | (新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。 |
| 3    | PUT     | (修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。 |
| 4    | DELETE  | (删除)请求服务器删除指定的资源。                             |
| 5    | HEAD    | HEAD  方法请求一个与 GET 请求的响应相同的响应，但没有响应体。 |
| 6    | OPTIONS | 获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。 |
| 7    | CONNECT | 建立一个到由目标资源标识的服务器的隧道。                     |
| 8    | TRACE   | 沿着到目标资源的路径执行一个消息环回测试，主要用于测试或诊断。 |
| 9    | PATCH   | 是对  PUT 方法的补充，用来对已知资源进行局部更新 。          |

## 5.5 HTTP响应状态代码

**HTTP** **响应状态码**（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态。

响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。



HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。

HTTP 状态码共分为 5 种类型：

| **分类** | **分类描述**                                                 |
| -------- | ------------------------------------------------------------ |
| 1**      | 信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到  1**  类型的状态码） |
| 2**      | 成功，操作被成功接收并处理                                   |
| 3**      | 重定向，需要进一步的操作以完成请求                           |
| 4**      | 客户端错误，请求包含语法错误或无法完成请求                   |
| 5**      | 服务器错误，服务器在处理请求的过程中发生了错误               |

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status

### 5.5.1 2**成功相关的相应状态码

2** 范围的状态码，表示服务器已成功接收到请求并进行处理。常见的 2** 类型的状态码如下：

| **状态码** | **状态码英文名称** | **中文描述**                                                 |
| ---------- | ------------------ | ------------------------------------------------------------ |
| 200        | OK                 | 请求成功。一般用于  GET 与 POST  请求                        |
| 201        | Created            | 已创建。成功请求并创建了新的资源，通常用于  POST 或 PUT  请求 |

### 5.5.2 3**重定向相关的响应状态码

3** 范围的状态码，表示表示服务器要求客户端重定向，需要客户端进一步的操作以完成资源的请求。常见的 3** 类型的状态码如下：

| 状态码 | **状态码英文名称** | **中文描述**                                                 |
| :----- | ------------------ | ------------------------------------------------------------ |
| 301    | Moved  Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found              | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 304    | Not  Modified      | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。 |

### 5.5.3 4**客户端错误相关的相应状态码

| 状态码 | 状态码英文名称  | **中文描述**                                                 |
| :----: | --------------- | ------------------------------------------------------------ |
|  400   | Bad  Request    | 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。  2、请求参数有误。 |
|  401   | Unauthorized    | 当前请求需要用户验证。                                       |
|  403   | Forbidden       | 服务器已经理解请求，但是拒绝执行它。                         |
|  404   | Not Found       | 服务器无法根据客户端的请求找到资源（网页）。                 |
|  408   | Request Timeout | 请求超时。服务器等待客户端发送的请求时间过长，超时。         |

### 5.5.4 5***服务端错误相关的响应状态码

5** 范围的状态码，表示服务器未能正常处理客户端的请求而出现意外错误。常见的 5** 类型的状态码如下：

| **状态码** | **状态码英文名称**     | **中文描述**                                                 |
| ---------- | ---------------------- | ------------------------------------------------------------ |
| 500        | Internal  Server Error | 服务器内部错误，无法完成请求。                               |
| 501        | Not  Implemented       | 服务器不支持该请求方法，无法完成请求。只有  GET 和 HEAD  请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501 |
| 503        | Service  Unavailable   | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。       |

# 6 Git

## 6.1 起步

### 6.1.1 版本控制软件

- 版本控制软件是一个用来记录文件变化，以便将来查阅特定版本修订情况的系统，因此有时也叫做“版本控制系统”。

- 好处：

1. 操作简便
2. 便于对比
3. 易于回溯
4. 不易丢失
5. 协作方便

### 6.1.2 本地版本控制系统

- 特点：使用软件来记录文件的不同版本，提高了工作效率，降低了手动维护版本的出错率

- 缺点：

①单机运行，不支持多人协作开发

②版本数据库故障后，所有历史更新记录会丢失

### 6.1.3 集中化版本控制系统

- 特点：基于服务器、客户端的运行模式

①服务器保存文件的所有更新记录

②客户端只保留最新的文件版本

- 优点：联网运行，支持多人协作开发

- 缺点：

①不支持离线提交版本更新

②中心服务器崩溃后，所有人无法正常工作

③版本数据库故障后，所有历史更新记录会丢失

### 6.1.4 分布式版本控制系统

- 特点：基于服务器、客户端的运行模式

1. 服务器保存文件的所有更新版本

2. 客户端是服务器的完整备份，并不是只保留文件的最新版本

- 优点：

①联网运行，支持多人协作开发

②客户端断网后支持离线本地提交版本更新

③服务器故障或损坏后，可使用任何一个客户端的备份进行恢复

### 6.1.5 Git概念

- Git 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。

- 特点：项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性！

- Git 之所以快速和高效，主要依赖于它的如下两个特性：

①直接记录快照，而非差异比较

②近乎所有操作都是本地执行

#### 1 SVN的差异比较

- 传统的版本控制系统（例如 SVN）是基于差异的版本控制，它们存储的是一组基本文件和每个文件随时间逐步累积的差异。

- 好处：节省磁盘空间

- 缺点：

  1. 耗时、效率低

  2. 在每次切换版本的时候，都需要在基本文件的基础上，应用每个差异，从而生成目标版本对应的文件。

![图片9](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106793.png)

#### 2 Git的记录快照

- Git 快照是在原有文件版本的基础上重新生成一份新的文件，类似于备份。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。

- 缺点：占用磁盘空间较大

- 优点：版本切换时非常快，因为每个版本都是完整的文件快照，切换版本时直接恢复目标版本的快照即可。

- 特点：空间换时间

![图片10](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106689.png)



在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。



特性：

①断网后依旧可以在本地对项目进行版本管理

②联网后，把本地修改的记录同步到云端服务器即可

![图片11](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020106418.png)

#### 3 区域

使用 Git 管理的项目，拥有三个区域，分别是工作区、暂存区、Git 仓库。

#### 4 Git的三种状态

**已修改**：表示修改了文件，但还没将修改的结果放到暂存区

**已暂存**：表示对已修改文件的当前版本做了标记，使之包含在下次提交的列表中

**已提交**：表示文件已经安全地保存在本地的 Git 仓库中

注意：

- 工作区的文件被修改了，但还没有放到暂存区，就是已修改状态。

- 如果文件已修改并放入暂存区，就属于已暂存状态。

- 如果 Git 仓库中保存着特定版本的文件，就属于已提交状态。

#### 5  工作流程

基本的 Git 工作流程如下：

①在工作区中修改文件

②将你想要下次提交的更改进行暂存

③提交更新，找到暂存区的文件，将快照永久性存储到 Git 仓库

![图片12](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020107179.png)



## 6.2 Git 基础

https://git-scm.com/downloads

### 6.2.1 配置用户信息

安装完 Git 之后，要做的第一件事就是设置自己的用户名和邮件地址。因为通过 Git 对项目进行版本管理的时候，Git 需要使用这些基本信息，来记录是谁对项目进行了操作：

注意：如果使用了 --global 选项，那么该命令只需要运行一次，即可永久生效。



通过 git config --global user.name 和 git config --global user.email 配置的用户名和邮箱地址，会被写入到 C:/Users/用户名文件夹/.gitconfig 文件中。这个文件是 Git 的**全局配置文件**，**配置一次即可永久生效**。



可以使用记事本打开此文件，从而查看自己曾经对 Git 做了哪些全局性的配置。

### 6.2.2 检测配置信息

除了使用记事本查看全局的配置信息之外，还可以运行如下的终端命令，快速的查看 Git 的全局配置信息：

### 6.2.3 帮助信息

可以使用 git help <verb> 命令，无需联网即可在浏览器中打开帮助手册，例如：

```git
git help config
git config -h
```

### 6.2.4 获取git仓库的方法

①将尚未进行版本控制的本地目录**转换**为 Git 仓库

②从其它服务器**克隆**一个已存在的 Git 仓库

以上两种方式都能够在自己的电脑上得到一个可用的 Git 仓库

#### 1 在现有目录中初始化仓库

如果自己有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，需要执行如下两个步骤：

①在项目目录中，通过鼠标右键打开“Git Bash”

②执行 git init 命令将当前的目录转化为 Git 仓库



git init 命令会创建一个名为 .git 的隐藏目录，**这个** **.git** **目录就是当前项目的** **Git** **仓库**，里面包含了初始的必要文件，这些文件是 Git 仓库的必要组成部分。

### 6.2.5 工作区文件的四种状态

![QQ截图20220823225956](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020107001.jpg)

### 6.2.6 检查文件的状态

可以使用 git status 命令查看文件处于什么状态，例如：
![图片13](https://picgo-1259245122.cos.ap-shanghai.myqcloud.com/img/note/Nodejs/202209020107963.png)
在状态报告中可以看到新建的 index.html 文件出现在 Untracked files（未跟踪的文件) 下面。



未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非明确地告诉它“我需要使用 Git 跟踪管理该文件”。

### 6.2.7 以精简的方式显示文件状态

使用 git status 输出的状态报告很详细，但有些繁琐。如果希望以精简的方式显示文件的状态，可以使用如下两条完全等价的命令，其中 **-s** 是 **--short** 的简写形式

### 6.2.8 跟踪新文件

使用命令 git add 开始跟踪一个文件。 所以，要跟踪 index.html 文件

### 6.2.9 提交更新

现在暂存区中有一个 index.html 文件等待被提交到 Git 仓库中进行保存。可以执行 git commit 命令进行提交,其中 -m 选项后面是本次的提交消息，用来对提交的内容做进一步的描述

### 6.2.10 暂存已修改的文件

目前，工作区中的 index.html 文件已被修改，如果要暂存这次修改，需要再次运行 git add 命令，这个命令是个多功能的命令，主要有如下 3 个功效：

①可以用它开始跟踪新文件

②把已跟踪的、且已修改的文件放到暂存区

③把有冲突的文件标记为已解决状态



### 6.2.11 提交已暂存的文件

```
 git commit -m "提交消息" 
```

### 6.2.12 撤销对文件的修改

```
git checkout --filename
```

### 6.2.13 向暂存区中一次性添加多个文件

```
git add .
```

### 6.2.14 取消暂存的文件

```
git reset HEAD 要移除的文件名称
```

### 6.2.15 跳过使用暂存区域

Git 标准的工作流程是工作区 → 暂存区 → Git 仓库，但有时候这么做略显繁琐，此时可以跳过暂存区，直接将工作区中的修改提交到 Git 仓库，这时候 Git 工作的流程简化为了工作区 → Git 仓库。

Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：

```
git commit -a -m "描述信息"
```

### 6.2.16 移除文件

从 Git 仓库中移除文件的方式有两种：

①从 Git 仓库和工作区中同时移除对应的文件

②只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件

```
// Git 仓库和工作区中同时移除对应的文件
git rm -f filename
// 只从 Git 仓库中移除指定的文件，但保留工作区中对应的文件
git rm --cached filename
```

### 6.2.17 忽略文件

一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 在这种情况下，我们可以创建一个名为 .gitignore 的配置文件，列出要忽略的文件的匹配模式。

文件 .gitignore 的格式规范如下：

①以 # 开头的是注释

②以 / 结尾的是目录

③以 / 开头防止递归

④以 ! 开头表示取反

⑤可以使用 glob 模式进行文件和文件夹的匹配（glob 指简化了的正则表达式）

### 6.2.18 glob模式

所谓的 glob 模式是指简化了的正则表达式：

① **星号 \*** 匹配零个或多个任意字符

② **[abc]** 匹配任何一个列在方括号中的字符 （此案例匹配一个 a 或匹配一个 b 或匹配一个 c）

③ **问号** **?** 只匹配一个任意字符

④ 在方括号中使用**短划线**分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）

⑤ **两个星号 \**** 表示匹配任意中间目录（比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等）

### 6.2.19 查看提交历史

如果希望回顾项目的提交历史，可以使用 git log 这个简单且有效的命令。

```
# 按照时间先后顺序列出所有的提交历史，最近的提交排在最上面
git log 
# 只展示最新的两条提交历史，数字可以按需进行填写
git log -2
# 在一行上展示最近两条提交历史的信息
git log -2 --pretty=oneline
# 在一行上展示最近两条提交历史的信息，并自定义输出的格式
# %h 提交的简写哈希值 %an作者名字 %ar作者修订日期，按多久以前的方式显示 %s提交说明
git log -2 --pretty=format:"%h | %an | %ar | %s"
```



### 6.2.20 回退到指定的版本

```
# 在一行上显示所有的提交历史
git log --pretty=oneline

# 使用git reset --hard 命令，根据指定的提交ID回退到指定版本
git reset --hard <commit ID>

# 在旧版本中使用git reflog --pretty=online命令，查看命令操作的历史
git reflog -- pretty =oneline

# 再根据最新的提交ID，跳转到最新版本
git reset  --hard <commit ID>
```

## 6.3 Github

### 6.3.1 Github 远程仓库使用

Github 上的远程仓库，有两种访问方式，分别是 HTTPS 和 SSH。它们的区别是：

①HTTPS：零配置；但是每次访问仓库时，需要重复输入 Github 的账号和密码才能访问成功

②SSH：需要进行额外的配置；但是配置成功后，每次访问仓库时，不需重复输入 Github 的账号和密码



注意：在实际开发中，推荐使用 SSH 的方式访问远程仓库。

```
// 本地没有现成的Git仓库
git init  
git add README.md
git commit -m "first commit"
git remote add origin https://
git push -u origin master

// 本地有现成的Git仓库
git remote add origin https://
git push -u origin master
```

### 6.3.2 SSH key

SSH key 的**作用**：实现本地仓库和 Github 之间免登录的加密数据传输。

SSH key 的**好处**：免登录身份认证、数据加密传输。

SSH key 由**两部分组成**，分别是：

①id_rsa（私钥文件，存放于客户端的电脑中即可）

②id_rsa.pub（公钥文件，需要配置到 Github 中）

#### 1 生成SSH key

①打开 Git Bash

②粘贴如下的命令，并将 your_email@example.com 替换为注册 Github 账号时填写的邮箱：

- ssh-keygen -t rsa -b 4096 -C "your_email@example.com"

③连续敲击 3 次回车，即可在 C:\Users\用户名文件夹\.ssh 目录中生成 id_rsa 和 id_rsa.pub 两个文件

2 配置SSH key

①使用记事本打开 id_rsa.pub 文件，复制里面的文本内容

②在浏览器中登录 Github，点击头像 -> Settings -> SSH and GPG Keys -> New SSH key

③将 id_rsa.pub 文件中的内容，粘贴到 Key 对应的文本框中

④在 Title 文本框中任意填写一个名称，来标识这个 Key 从何而来

#### 3 检测是否配置成功

```
ssh -T git@github.com
```

4 基于SSH将本地仓库上传到Github

```
git remote add origin git@github.com:
git push -u origin master
```



## 6.4 Git 分支

### 6.4.1 master 主分支

在初始化本地 Git 仓库的时候，Git 默认已经帮我们创建了一个名字叫做 master 的分支。通常我们把这个 master 分支叫做主分支。

### 6.4.2 查看分支列表

```
git branch
```

### 6.4.3 创建新分支

使用如下的命令，可以基于当前分支，创建一个新的分支，此时，新分支中的代码和当前分支完全一样：

```
git branch 分支名称
```

### 6.4.4 切换分支

使用如下的命令，可以切换到指定的分支上进行开发：

```
git checkout 分支名称
```

### 6.4.5 分支的快速创建和切换

使用如下的命令，可以创建指定名称的新分支，并立即切换到新分支上：

```
# -b 表示创建一个新分支
# checkout 表示切换到刚才新建的分支上
git checkout -b 分支名称
```

### 6.4.6 合并分支

```
# 1.切换到master分支
git checkout master
# 2.在master分支上运行git merge命令，将login分支的代码合并到master分支上
git merge login
```

### 6.4.7 删除分支

```
git branch -d 分支名称
```

### 6.4.8 遇到冲突时的分支合并

如果在两个不同的分支中，对同一个文件进行了不同的修改，Git 就没法干净的合并它们。 此时，我们需要打开这些包含冲突的文件然后**手动解决冲突**。

```
# 假设:在把reg分支合并到master分支期间，代码发生了冲突
git checkout master
git merge reg

# 打开包含冲突的文件，手动解决冲突之后，在执行如下命令
git add .
git commit -m "解决了分支合并冲突的问题"
```

### 6.4.9 将本地分支推送到远程仓库

```
# -u 表示把本地分支和远程分支进行关联，只在第一推送的时候需要带 -u 参数
git push -u 远程仓库的别名 本地分支名称：远程分支名称

#实际案例：
git push -u orgin payment：pay

# 如果希望远程分支的名称和本地分支保持一致，可以对命令进行简化
git push -u orgin payment
```

注意：第一次推送分支需要带 -u 参数，此后可以直接使用 git push 推送代码到远程分支。

### 6.4.10 查看远程仓库中所有的分支列表

```
git remote show 远程仓库名称
```

### 6.4.11 跟踪分支

跟踪分支指的是：从远程仓库中，把远程分支下载到本地仓库中。需要运行的命令如下：

```
# 从远程仓库中，把对应的远程分支下载到本地仓库，保持本地分支和远程分支名称相同
git checkout 远程分支的名称
# 实例：
git checkout pay

# 从远程仓库中，把对应的远程分支下载到本地仓库，并把下载的本地分支进行重命名
git checkout -b 本地分支名称 远程仓库名称/远程分支名称
# 实例：
git checkout -b payment orgin/pay
```

### 6.4.12 拉取远程分支的最新的代码

可以使用如下的命令，把远程分支最新的代码下载到本地对应的分支中：

```
git pull
```

### 6.4.13 删除远程分支

```
git push 远程仓库名称 --delete 远程分支名称
```

## 6.5 git常用代码

```
# 第一次初始化(方式1)：
git init
git add .
git commit -m 'first commit'
git remote add origin git@github.com:帐号名/仓库名.git
git pull origin master
git push origin master # -f 强推

# 第一次初始化(方式2)：
git clone git@github.com:git帐号名/仓库名.git

# 平时工作基本操作：
git checkout master # 切到主分支
git fetch origin  # 获取最新变更
git checkout -b dev origin/master # 基于主分支创建dev分支
git add . # 添加到缓存
git commit -m 'xxx' # 提交到本地仓库
git fetch origin # 获取最新变更
git rebase dev origin/master # 合并到主分支
git push origin dev # 推送到远程分支

git chekout master # 切到主分支
git merge dev # 合并开发分支

git clone -b 远程分支 仓库地址 # 本地不存在仓库 拉取远程分支代码
git checkout -b 远程分支 origin/远程分支 # 本地存在仓库，拉取远程分支


# 初始化仓库
git init

# 查看仓库当前状态
git status

# 将文件添加到仓库
git add 文件名 # 将工作区的某个文件添加到暂存区   
git add . # 将当前工作区的所有文件都加入暂存区
git add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件
git add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件
git add -i # 进入交互界面模式，按需添加文件到缓存区

# 将暂存区文件提交到本地仓库
git commit -m "提交说明" # 将暂存区内容提交到本地仓库
git commit -a -m "提交说明" # 跳过缓存区操作，直接把工作区内容提交到本地仓库

# 比较文件异同
git diff # 工作区与暂存区的差异
git diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名
git diff HEAD  # 工作区与HEAD指针指向的内容差异
git diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异
git diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached)
git diff 版本TAG # 查看从某个版本后都改动内容
git diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)
git diff 分支A...分支B # 比较两分支在分开后各自的改动
# 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数 

# 查看历史记录
git log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)
git log -p -次数 # 查看最近多少次的提交记录
git log --stat # 简略显示每次提交的内容更改
git log --name-only # 仅显示已修改的文件清单
git log --name-status # 显示新增，修改，删除的文件清单
git log --oneline # 让提交记录以精简的一行输出
git log –graph –all --online # 图形展示分支的合并历史
git log --author=作者  # 查询作者的提交记录(和grep同时使用要加一个--all--match参数)
git log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录
git log -S查询内容 # 和--grep类似，S和查询内容间没有空格
git log fileName # 查看某文件的修改记录，找背锅专用

# 代码回滚
git reset HEAD^ # 恢复成上次提交的版本
git reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数
git reflog
git reset --hard 版本号
--soft：只是改变HEAD指针指向，缓存区和工作区不变；
--mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；
--hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；

# 同步远程仓库
git push -u origin master

# 删除版本库文件
git rm 文件名 

# 版本库里的版本替换工作区的版本
git checkout -- test.txt

# 本地仓库内容推送到远程仓库
git remote add origin git@github.com:帐号名/仓库名.git

# 从远程仓库克隆项目到本地
git clone git@github.com:git帐号名/仓库名.git

# 创建分支
git checkout -b dev
-b表示创建并切换分支
上面一条命令相当于一面的二条：
git branch dev //创建分支
git checkout dev //切换分支

# 查看分支
git branch

# 合并分支
git merge dev  #用于合并指定分支到当前分支
git merge --no-ff -m "merge with no-ff" dev  #加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并

# 删除分支
git branch -d dev

# 查看分支合并图
git log --graph --pretty=oneline --abbrev-commit

# 查看远程库信息
git remote

# git相关配置
# 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：
git config --global user.name "用户名" # 设置用户名
git config --global user.email "用户邮箱"   #设置邮箱
git config --global user.name   # 查看用户名是否配置成功
git config --global user.email   # 查看邮箱是否配置

# 其他查看配置相关
git config --global --list  # 查看全局设置相关参数列表
git config --local --list # 查看本地设置相关参数列表
git config --system --list # 查看系统配置参数列表
git config --list  # 查看所有Git的配置(全局+本地+系统)
git config --global color.ui true //显示git相关颜色

# 撤消某次提交
git revert HEAD # 撤销最近的一个提交
git revert 版本号 # 撤销某次commit

# 拉取远程分支到本地仓库
git checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支
git fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkout
git branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接

# 标签
git tag 标签 //打标签命令，默认为HEAD
git tag //显示所有标签
git tag 标签 版本号 //给某个commit版本添加标签
git show 标签 //显示某个标签的详细信息

# 同步远程仓库更新
git fetch  origin master
```



